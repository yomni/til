# 쿼리 실행 구조

![](2_query-exec-order.png)

## 쿼리 파서

사용자의 쿼리 문장을 트리 형태로 **_분해_** 한다. 기본적인 문법 오류를 발견할 수 있다.

아래와 같은 로직으로 구동될 것으로 예상

- SELECT 다음 컬럼명이 나온다. 공백(white space)를 기준으로 Select와 컬럼을 나눈다.
- 컬럼은 콤마(,)를 기준으로 분리한다. 컬럼 사이에 있는 공백(white space)은 무시한다.
    - FROM 이란 키워드가 나올 때 까지 컬럼 리스트를 취합한다.
- FROM 이란 키워드가 나오면 그 다음엔 [스키마명.]테이블명이 나온다.
- ...

## 전처리기

파서 트리를 기준으로 구조적인 문제가 있는 지 확인한다.  
테이블 이름이나, 컬럼 이름, 함수명 등에 대해 유효성 검사를 한다(validation)

## 옵티마이저 (진짜 매우 중요) ; 경영진

쿼리 실행 구조를 하나의 회사로 비유하면, 옵티마이저는 경영진에 속한다.

- 비효율적인 쿼리를 효율적인 쿼리로 개선한다.
    - 이 과정에서 비용을 최적화 한다.
- **_실행 계획을 세운다._**

**_대부분 쿼리 튜닝이라 함은, 옵티마이저가 실행계획을 잘 세울 수 있도록 가이드 하는 것이다._**

### Q) 비효율적인지 효율적인지 어떻게 알아?

- 데이터 분포도, 인덱스, ... 등등 종합적으로 고려하여 판단한다.

## 실행 엔진(쿼리 실행기) ; 중간 관리자

쿼리를 실행한다. == 핸들러(스토리지 엔진) 에게 데이터를 가져오라고 시킨다.

결과를 요청한 사용자에게 돌려준다.

## 핸들러(스토리지 엔진) ; 실무진

**_실제 디스크에 저장되어 있는 데이터를 읽는다._**

InnoDB의 경우

- 단순히 디스크 I/O를 하는 것이 아니라, 여러 로그 - 버퍼풀 등을 활용하여 디스크 I/O를 최소화 하려고 한다.
- 격리 수준을 다양화 하여 쓰는 동시에 이전 데이터를 조회할 수 있거나 여러 시나리오에서 효율적인 접근이 가능하다.

## 느낀점

- 레이어드 아키텍처, SRP가 또 여기서 연계되어 생각난다.
- 만약 맨 바닥부터 MySQL을 직접 만드는 상상을 해보게 되었다. 쿼리 파서에서는 신나게 String을 조작하고, 유효성 검사하고, ...
